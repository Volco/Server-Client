#!/usr/bin/env node
'use strict';

const fs = require("fs");
const path = require('path');
const child_process = require("child_process");

// Make sure this is true when committing
const isVPS = true;

const vpsDawnPath = '/home/dawn/Dawn/';
const localDawnPath = '../../Dawn/';

const dawnPath = isVPS ? vpsDawnPath : localDawnPath;

const rootDir = path.resolve(__dirname, '..');
process.chdir(rootDir);


if (!fs.existsSync('caches/pokemon-showdown')) {
	child_process.execSync('git clone https://github.com/smogon/pokemon-showdown.git', {
		cwd: 'caches',
	});
}

process.stdout.write("Syncing data from Git repository... ");
child_process.execSync('git pull', {cwd: 'caches/pokemon-showdown'});
child_process.execSync('npm run build', {cwd: 'caches/pokemon-showdown'});
console.log("DONE");

const Dex = require('../caches/pokemon-showdown/dist/sim/dex').Dex;
const DawnDex = require(dawnPath + 'dist/sim/dex').Dex;
const toID = Dex.toID;
process.stdout.write("Loading gen 6 data... ");
Dex.includeData();
console.log("DONE");

function es3stringify(obj) {
	const buf = JSON.stringify(obj);
	return buf.replace(/\"([A-Za-z][A-Za-z0-9]*)\"\:/g, (fullMatch, key) => (
		['return', 'new', 'delete'].includes(key) ? fullMatch : `${key}:`
	));
}

function requireNoCache(pathSpec) {
	delete require.cache[require.resolve(pathSpec)];
	return require(pathSpec);
}

/*********************************************************
 * Build search-index.js
 *********************************************************/

{
	process.stdout.write("Building `data/search-index.js`... ");

	let index = [];

	index = index.concat(Object.keys(Dex.data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(Dex.data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(Dex.data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(Dex.data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(Dex.data.TypeChart).map(x => toID(x) + ' type'));

	// Gen 9 Sanctified
	index = index.concat(Object.keys(DawnDex.mod('gen9sanctified').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen9sanctified').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen9sanctified').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen9sanctified').data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(DawnDex.mod('gen9sanctified').data.TypeChart).map(x => toID(x) + ' type'));
	// Gen 9 Universal
	index = index.concat(Object.keys(DawnDex.mod('gen9universal').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen9universal').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen9universal').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen9universal').data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(DawnDex.mod('gen9universal').data.TypeChart).map(x => toID(x) + ' type'));
	// Omnifield
	index = index.concat(Object.keys(DawnDex.mod('omnifield').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('omnifield').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('omnifield').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('omnifield').data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(DawnDex.mod('omnifield').data.TypeChart).map(x => toID(x) + ' type'));
	// Gen 9 Espionage
	index = index.concat(Object.keys(DawnDex.mod('gen9espionage').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen9espionage').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen9espionage').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen9espionage').data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(DawnDex.mod('gen9espionage').data.TypeChart).map(x => toID(x) + ' type'));
	// Gen 9 Rebalanced
	index = index.concat(Object.keys(DawnDex.mod('gen9rebalanced').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen9rebalanced').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen9rebalanced').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen9rebalanced').data.Abilities).map(x => x + ' ability'));
	// Gen 9 GPT
	index = index.concat(Object.keys(DawnDex.mod('gen9gpt').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen9gpt').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen9gpt').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen9gpt').data.Abilities).map(x => x + ' ability'));
	// Gen 5 Xenoverse
	index = index.concat(Object.keys(DawnDex.mod('gen5Xenoverse').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen5Xenoverse').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen5Xenoverse').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen5Xenoverse').data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(DawnDex.mod('gen5Xenoverse').data.TypeChart).map(x => toID(x) + ' type'));
	// Gen 6 Blazing Emerald
	index = index.concat(Object.keys(DawnDex.mod('gen6blazing').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen6blazing').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen6blazing').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen6blazing').data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(DawnDex.mod('gen6blazing').data.TypeChart).map(x => toID(x) + ' type'));
	// Gen 6 Ininfinity
	index = index.concat(Object.keys(DawnDex.mod('gen6infinity').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen6infinity').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen6infinity').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen6infinity').data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(DawnDex.mod('gen6infinity').data.TypeChart).map(x => toID(x) + ' type'));
	// Gen 7 Daybreak
	index = index.concat(Object.keys(DawnDex.mod('gen7daybreak').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen7daybreak').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen7daybreak').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen7daybreak').data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(DawnDex.mod('gen7daybreak').data.TypeChart).map(x => toID(x) + ' type'));	
	// Gen 8 Untamed
	index = index.concat(Object.keys(DawnDex.mod('gen8untamed').data.Pokedex).map(x => x + ' pokemon'));
	index = index.concat(Object.keys(DawnDex.mod('gen8untamed').data.Moves).map(x => x + ' move'));
	index = index.concat(Object.keys(DawnDex.mod('gen8untamed').data.Items).map(x => x + ' item'));
	index = index.concat(Object.keys(DawnDex.mod('gen8untamed').data.Abilities).map(x => x + ' ability'));
	index = index.concat(Object.keys(DawnDex.mod('gen8untamed').data.TypeChart).map(x => toID(x) + ' type'));
	// Remove dupes
	index = [...new Set(index)];

	index = index.concat(['physical', 'special', 'status'].map(x => toID(x) + ' category'));
	index = index.concat(['monster', 'water1', 'bug', 'flying', 'field', 'fairy', 'grass', 'humanlike', 'water3', 'mineral', 'amorphous', 'water2', 'ditto', 'dragon', 'undiscovered'].map(x => toID(x) + ' egggroup'));
	index = index.concat(['ou', 'uu', 'ru', 'nu', 'pu', 'zu', 'lc', 'nfe', 'uber', 'uubl', 'rubl', 'nubl', 'publ', 'zubl', 'cap', 'caplc', 'capnfe', 'hubl', 'hu', 'aubl', 'au', 'oubl', 'fubl', 'fu'].map(x => toID(x) + ' tier'));

	let BattleArticleTitles = {};

	try {
		for (const file of fs.readdirSync('../dex.pokemonshowdown.com/articles/')) {
			if (file.endsWith('.md')) {
				const id = file.slice(0, -3);
				const contents = '' + fs.readFileSync('../dex.pokemonshowdown.com/articles/' + file);
				if (contents.startsWith('# ')) {
					const title = contents.slice(2, contents.indexOf('\n'));
					if (title !== id.charAt(0).toUpperCase() + id.slice(1)) {
						BattleArticleTitles[id] = title;
					}
				}
				index.push('' + id + ' article');
			}
		}
	} catch (e) {
		console.log('\n(WARNING: NO ARTICLES)');
	}
	index.push('pokemon article');
	index.push('moves article');

	// generate aliases
	function generateAlias(id, name, type) {
		let i = name.lastIndexOf(' ');
		if (i < 0) i = name.lastIndexOf('-');
		if (name.endsWith('-Mega-X') || name.endsWith('-Mega-Y')) {
			index.push('mega' + toID(name.slice(0, -7) + name.slice(-1)) + ' ' + type + ' ' + id + ' 0');
			index.push('m' + toID(name.slice(0, -7) + name.slice(-1)) + ' ' + type + ' ' + id + ' 0');
			index.push('mega' + toID(name.slice(-1)) + ' ' + type + ' ' + id + ' ' + toID(name.slice(0, -7)).length);
			return;
		}
		if (name.endsWith('-Mega')) {
			index.push('mega' + toID(name.slice(0, -5)) + ' ' + type + ' ' + id + ' 0');
			index.push('m' + toID(name.slice(0, -5)) + ' ' + type + ' ' + id + ' 0');
			return;
		}
		if (name.endsWith('-Alola')) {
			index.push('alolan' + toID(name.slice(0, -6)) + ' ' + type + ' ' + id + ' 0');
			return;
		}
		let oldI = i;
		if (name === 'Alakazam') i = 5;
		if (name === 'Arctovish') i = 5;
		if (name === 'Arctozolt') i = 5;
		if (name === 'Articuno') i = 5;
		if (name === 'Breloom') i = 3;
		if (name === 'Bronzong') i = 4;
		if (name === 'Celebi') i = 4;
		if (name === 'Charizard') i = 5;
		if (name === 'Donphan') i = 3;
		if (name === 'Dracovish') i = 5;
		if (name === 'Dracozolt') i = 5;
		if (name === 'Dragapult') i = 5;
		if (name === 'Dusclops') i = 3;
		if (name === 'Electabuzz') i = 6;
		if (name === 'Exeggutor') i = 2;
		if (name === 'Garchomp') i = 3;
		if (name === 'Hariyama') i = 4;
		if (name === 'Magearna') i = 2;
		if (name === 'Magnezone') i = 5;
		if (name === 'Mamoswine') i = 4;
		if (name === 'Moltres') i = 3;
		if (name === 'Nidoking') i = 4;
		if (name === 'Nidoqueen') i = 4;
		if (name === 'Nidorina') i = 4;
		if (name === 'Nidorino') i = 4;
		if (name === 'Regice') i = 3;
		if (name === 'Regidrago') i = 4;
		if (name === 'Regieleki') i = 4;
		if (name === 'Regigigas') i = 4;
		if (name === 'Regirock') i = 4;
		if (name === 'Registeel') i = 4;
		if (name === 'Slowbro') i = 4;
		if (name === 'Slowking') i = 4;
		if (name === 'Starmie') i = 4;
		if (name === 'Tyranitar') i = 6;
		if (name === 'Zapdos') i = 3;

		if (name === 'Acupressure') i = 3;
		if (name === 'Aromatherapy') i = 5;
		if (name === 'Boomburst') i = 4;
		if (name === 'Crabhammer') i = 4;
		if (name === 'Discharge') i = 3;
		if (name === 'Earthquake') i = 5;
		if (name === 'Extrasensory') i = 5;
		if (name === 'Flamethrower') i = 5;
		if (name === 'Headbutt') i = 4;
		if (name === 'Moonblast') i = 4;
		if (name === 'Moonlight') i = 4;
		if (name === 'Overheat') i = 4;
		if (name === 'Outrage') i = 3;
		if (name === 'Octazooka') i = 4;
		if (name === 'Payback') i = 3;
		if (name === 'Psyshock') i = 3;
		if (name === 'Psywave') i = 3;
		if (name === 'Rototiller') i = 4;
		if (name === 'Rollout') i = 4;
		if (name === 'Safeguard') i = 4;
		if (name === 'Sandstorm') i = 4;
		if (name === 'Smokescreen') i = 5;
		if (name === 'Stockpile') i = 5;
		if (name === 'Steamroller') i = 5;
		if (name === 'Superpower') i = 5;
		if (name === 'Supersonic') i = 5;
		if (name === 'Synchronoise') i = 7;
		if (name === 'Tailwind') i = 4;
		if (name === 'Telekinesis') i = 4;
		if (name === 'Teleport') i = 4;
		if (name === 'Thunderbolt') i = 7;
		if (name === 'Twineedle') i = 3;
		if (name === 'Uproar') i = 2;
		if (name === 'Venoshock') i = 4;
		if (name === 'Whirlpool') i = 5;
		if (name === 'Whirlwind') i = 5;
		let acronym;
		if (oldI < 0 && i > 0) {
			acronym = toID(name.charAt(0) + name.slice(i));
		}
		if (i < 0) return;
		index.push('' + toID(name.slice(i)) + ' ' + type + ' ' + id + ' ' + toID(name.slice(0, i)).length);
		if (name.startsWith('Hidden Power ')) {
			acronym = 'hp' + toID(name.substr(13));
			index.push('' + acronym + ' ' + type + ' ' + id + ' 0');
		} else if (name === 'Hidden Power') {
			index.push('hp ' + type + ' ' + id + ' 0');
		} else if (name.includes(' ')) {
			acronym = toID(name.split(' ').map((x, i) => i !== 0 ? x : x.charAt(0)).join(''));
		} else if (name.includes('-') && name.charAt(1) !== '-') {
			acronym = toID(name.split('-').map((x, i) => i !== 0 ? x : x.charAt(0)).join(''));
		}
		if (acronym) {
			index.push('' + acronym + ' ' + type + ' ' + id + ' 0');
		}
		if (name === 'High Jump Kick') {
			index.push('hjkick ' + type + ' ' + id + ' 0');
		} else if (name === 'Wake-Up Slap') {
			index.push('wuslap ' + type + ' ' + id + ' 0');
			index.push('wupslap ' + type + ' ' + id + ' 0');
		} else if (name === 'Zen Headbutt') {
			index.push('zhbutt ' + type + ' ' + id + ' 0');
		} else if (name === 'Articuno') {
			index.push('cuno ' + type + ' ' + id + ' 4');
		}

		let i2 = name.lastIndexOf(' ', i - 1);
		if (i2 < 0) i2 = name.lastIndexOf('-', i - 1);
		if (name === 'Zen Headbutt') i2 = 8;
		if (i2 >= 0) {
			index.push('' + toID(name.slice(i2)) + ' ' + type + ' ' + id + ' ' + toID(name.slice(0, i2)).length);
		}
	}
	for (const id in Dex.data.Pokedex) {
		const name = Dex.data.Pokedex[id].name;
		generateAlias(id, name, 'pokemon');
	}
	for (const id in Dex.data.Moves) {
		const name = Dex.data.Moves[id].name;
		generateAlias(id, name, 'move');
	}
	for (const id in Dex.data.Items) {
		const name = Dex.data.Items[id].name;
		generateAlias(id, name, 'item');
	}
	for (const id in Dex.data.Abilities) {
		const name = Dex.data.Abilities[id].name;
		generateAlias(id, name, 'ability');
	}

	index.sort();

	// manually rearrange
	index[index.indexOf('grass type')] = 'grass egggroup';
	index[index.indexOf('grass egggroup')] = 'grass type';

	index[index.indexOf('fairy type')] = 'fairy egggroup';
	index[index.indexOf('fairy egggroup')] = 'fairy type';

	index[index.indexOf('flying type')] = 'flying egggroup';
	index[index.indexOf('flying egggroup')] = 'flying type';

	index[index.indexOf('dragon type')] = 'dragon egggroup';
	index[index.indexOf('dragon egggroup')] = 'dragon type';

	index[index.indexOf('bug type')] = 'bug egggroup';
	index[index.indexOf('bug egggroup')] = 'bug type';

	index[index.indexOf('psychic type')] = 'psychic move';
	index[index.indexOf('psychic move')] = 'psychic type';

	index[index.indexOf('ditto pokemon')] = 'ditto egggroup';
	index[index.indexOf('ditto egggroup')] = 'ditto pokemon';


	let BattleSearchIndex = index.map(x => {
		x = x.split(' ');
		if (x.length > 3) {
			x[3] = Number(x[3]);
			x[2] = index.indexOf(x[2] + ' ' + x[1]);
		}
		return x;
	});

	let BattleSearchIndexOffset = BattleSearchIndex.map((entry, i) => {
		const id = entry[0];
		let name = '';
		switch (entry[1]) {
		case 'pokemon': name = Dex.species.get(id).name; break;
		case 'move': name = Dex.moves.get(id).name; break;
		case 'item': name = Dex.items.get(id).name; break;
		case 'ability': name = Dex.abilities.get(id).name; break;
		case 'article': name = BattleArticleTitles[id] || ''; break;
		}
		let res = '';
		let nonAlnum = 0;
		for (let i = 0, j = 0; i < id.length; i++, j++) {
			while (!/[a-zA-Z0-9]/.test(name[j])) {
				j++;
				nonAlnum++;
			}
			res += nonAlnum;
		}
		if (nonAlnum) return res;
		return '';
	});

	let BattleSearchCountIndex = {};
	for (const type in Dex.data.TypeChart) {
		BattleSearchCountIndex[type + ' move'] = Object.keys(Dex.data.Moves).filter(id => (Dex.data.Moves[id].type === type)).length;
	}

	for (const type in Dex.data.TypeChart) {
		BattleSearchCountIndex[type + ' pokemon'] = Object.keys(Dex.data.Pokedex).filter(id => (Dex.data.Pokedex[id].types.indexOf(type) >= 0)).length;
	}

	let buf = '// DO NOT EDIT - automatically built with build-tools/build-indexes\n\n';

	buf += 'exports.BattleSearchIndex = ' + JSON.stringify(BattleSearchIndex) + ';\n\n';

	buf += 'exports.BattleSearchIndexOffset = ' + JSON.stringify(BattleSearchIndexOffset) + ';\n\n';

	buf += 'exports.BattleSearchCountIndex = ' + JSON.stringify(BattleSearchCountIndex) + ';\n\n';

	buf += 'exports.BattleArticleTitles = ' + JSON.stringify(BattleArticleTitles) + ';\n\n';

	fs.writeFileSync('play.pokemonshowdown.com/data/search-index.js', buf);
}

console.log("DONE");

/*********************************************************
 * Build teambuilder-tables.js
 *********************************************************/

process.stdout.write("Building `data/teambuilder-tables.js`... ");

{
	const BattleTeambuilderTable = {};

	let buf = '// DO NOT EDIT - automatically built with build-tools/build-indexes\n\n';
	const GENS = [9, 8, 7, 6, 5, 4, 3, 2, 1];
	const DOUBLES = GENS.filter(x => x > 2).map(num => -num);
	const VGC = GENS.filter(x => x > 3).map(num => -num - 0.5);
	const NFE = GENS.map(num => num + 0.3);
	const LC = GENS.map(num => num + 0.7);
	const STADIUM = [2.04, 1.04];
	const NATDEX = [9.1, 8.1];
	const OTHER = [9.9, 9.69, 9.68, 9.67, 9.66, 9.65, 9.64, 9.63, 9.411, 9.41, 9.401, 9.4, 9.2, -9.4, -9.401, 8.69, 8.6, 8.4, 8.2, 8.1, -8.4, -8.6, 7.69, 7.1, 6.69, 6.1, 5.69, 5.1];

	// process.stdout.write("\n  ");
	for (const genIdent of [...GENS, ...DOUBLES, ...VGC, ...NFE, ...STADIUM, ...OTHER, ...NATDEX, ...LC]) {
		const isLetsGo = (genIdent === 7.1);
		const isBDSP = (genIdent === 8.6 || genIdent === -8.6);
		const isSanctified = (genIdent === 9.69);
		const isUniversal = (genIdent === 9.68);
		const isOmnifield = (genIdent === 9.67);
		const isEspionage = (genIdent === 9.66);
		const isRebalanced = (genIdent === 9.65);
		const isGPT = (genIdent === 9.64);
		const is35Pokes = (genIdent === 9.63);
		const isUntamed = (genIdent === 8.69);
		const isDaybreak = (genIdent === 7.69);
		const isInfinity = (genIdent === 6.69);
		const isBlazing = (genIdent === 6.1);
		const isSpizzles = (genIdent === 5.69);
		const isXenoverse = (genIdent === 5.1);
		const isMetBattle = ('' + genIdent).endsWith('.2');
		const isNFE = ('' + genIdent).endsWith('.3');
		const isLC = ('' + genIdent).endsWith('.7');
		const isSSDLC1 = (genIdent === 8.4 || genIdent === -8.4);
		const isPreDLC = (genIdent === 9.4 || genIdent === 9.41 || genIdent === -9.4);
		const isSVDLC1 = (genIdent === 9.401 || genIdent === 9.411 || genIdent === -9.401);
		const isNatDex = ('' + genIdent).endsWith('.1') && genIdent > 8;
		const isStadium = ('' + genIdent).endsWith('.04');
		const isDoubles = (genIdent < 0);
		const isVGC = ('' + genIdent).endsWith('.5');
		const isGen9BH = genIdent === 9.9;
		const genNum = Math.floor(isDoubles ? -genIdent : genIdent);
		const gen = (() => {
			let genStr = 'gen' + genNum;
			if (isSSDLC1) genStr += 'dlc1';
			if (isLetsGo) genStr += 'letsgo';
			if (isBDSP) genStr += 'bdsp';
			if (isPreDLC) genStr += 'predlc';
			if (isSVDLC1) genStr += 'dlc1';
			if (isStadium) genStr += 'stadium' + (genNum > 1 ? genNum : '');
			return genStr;
		})();
		// process.stdout.write("" + gen + (isDoubles ? " doubles" : "") + "... ");
		const pokemon = Object.keys(Dex.data.Pokedex);
		const SanctifiedPokemon = Object.keys(DawnDex.mod('gen9sanctified').data.Pokedex);
		const UniversalPokemon = Object.keys(DawnDex.mod('gen9universal').data.Pokedex);
		const OmnifieldPokemon = Object.keys(DawnDex.mod('omnifield').data.Pokedex);
		const EspionagePokemon = Object.keys(DawnDex.mod('gen9espionage').data.Pokedex);
		const RebalancedPokemon = Object.keys(DawnDex.mod('gen9rebalanced').data.Pokedex);
		const GPTPokemon = Object.keys(DawnDex.mod('gen9gpt').data.Pokedex);
		const XenoversePokemon = Object.keys(DawnDex.mod('gen5Xenoverse').data.Pokedex);
		const BlazingPokemon = Object.keys(DawnDex.mod('gen6blazing').data.Pokedex);
		const IninfinityPokemon = Object.keys(DawnDex.mod('gen6infinity').data.Pokedex);
		const DaybreakPokemon = Object.keys(DawnDex.mod('gen7daybreak').data.Pokedex);
		const UntamedPokemon = Object.keys(DawnDex.mod('gen8untamed').data.Pokedex);
		pokemon.sort();
		SanctifiedPokemon.sort();
		UniversalPokemon.sort();
		OmnifieldPokemon.sort();
		EspionagePokemon.sort();
		RebalancedPokemon.sort();
		GPTPokemon.sort();
		XenoversePokemon.sort();
		BlazingPokemon.sort();
		IninfinityPokemon.sort();
		DaybreakPokemon.sort();
		UntamedPokemon.sort();
		const tierTable = {};
		const overrideTier = {};
		const ubersUUBans = {};
		const monotypeBans = {};
		const nonstandardMoves = [];
		let invalidSanctifiedSpecies = [];
		for (const id of pokemon) {
			const species = Dex.mod(gen).species.get(id);
			const baseSpecies = Dex.mod(gen).species.get(species.baseSpecies);
			if (species.gen > genNum) continue;
			if (isSanctified) continue;
			if (isUniversal) continue;
			if (isOmnifield) continue;
			if (isEspionage) continue;
			if (isRebalanced) continue;
			if (isGPT) continue;
			if (is35Pokes) continue;
			if (isXenoverse) continue;
			if (isBlazing) continue;
			if (isInfinity) continue;
			if (isDaybreak) continue;
			if (isUntamed) continue;
			const tier = (() => {
				if (isMetBattle) {
					let tier = species.tier;
					if (species.isNonstandard) {
						if (species.isNonstandard === 'Past') {
							tier = Dex.mod('gen7').species.get(species.name).tier;
						} else {
							tier = 'OU';
						}
					}
					if (species.isNonstandard === 'Gigantamax') tier = '(Uber)';
					if (species.tier === 'CAP LC') tier = 'LC';
					if (species.tier === 'CAP NFE') tier = 'NFE';
					if (species.tier === 'CAP') tier = 'OU';
					const format = Dex.formats.get(gen + 'metronomebattle');
					let bst = 0;
					for (const stat of Object.values(species.baseStats)) {
						bst += stat;
					}
					if (bst > 625) tier = 'Illegal';
					if (Dex.formats.getRuleTable(format).isBannedSpecies(species)) tier = 'Illegal';
					if (species.types.includes('Steel')) tier = 'Illegal';
					return tier;
				}
				if (isNFE) {
					let tier = species.tier;
					if (!species.nfe) tier = 'Illegal';
					const format = Dex.formats.get(gen + 'nfe');
					const banlist = Dex.formats.getRuleTable(format);
					if (banlist.isBannedSpecies(species)) {
						tier = 'Uber';
					}
					return tier;
				}
				if (isLC) {
					let tier = species.tier;
					const lc = Dex.formats.get(gen + 'lc');
					const lcBanlist = Dex.formats.getRuleTable(lc);
					if (!species.nfe || species.prevo || lcBanlist.isBannedSpecies(species)) {
						tier = 'Illegal';
					}
					if (/^([OURNPZ]U(BL)?|Uber|AG)$/g.test(tier) && tier !== 'Illegal') {
						tier = 'LC';
					}
					return tier;
				}
				if (isLetsGo) {
					let validNum = (baseSpecies.num <= 151 && species.num >= 1) || [808, 809].includes(baseSpecies.num);
					if (!validNum) return 'Illegal';
					if (species.forme && !['Alola', 'Mega', 'Mega-X', 'Mega-Y', 'Starter'].includes(species.forme)) return 'Illegal';
					if (species.name === 'Pikachu-Alola') return 'Illegal';
					return species.tier;
				}
				if (isVGC) {
					if (species.isNonstandard && species.isNonstandard !== 'Gigantamax') return 'Illegal';
					if (baseSpecies.tags.includes('Mythical')) return 'Mythical';
					if (baseSpecies.tags.includes('Restricted Legendary')) return 'Restricted Legendary';
					if (species.tier === 'NFE') return 'NFE';
					if (species.tier === 'LC') return 'LC';
					return 'Regular';
				}
				if (isGen9BH) {
					if ((species.natDexTier === 'Illegal' || species.forme.includes('Totem')) &&
						!['Floette-Eternal', 'Greninja-Ash', 'Xerneas-Neutral'].includes(species.name)) {
						return 'Illegal';
					}
					if ((species.name === 'Xerneas' || species.battleOnly || species.forme === 'Eternamax') &&
						!(species.isMega || species.isPrimal || ['Greninja-Ash', 'Necrozma-Ultra'].includes(species.name))) {
						return 'Illegal';
					}
					if (species.isNonstandard && ['LGPE', 'CAP', 'Future'].includes(species.isNonstandard)) return 'Illegal';
					return species.tags.includes('Mythical') ? 'Mythical' :
						species.tags.includes('Restricted Legendary') ? 'Restricted Legendary' :
							species.nfe ? (species.prevo ? 'NFE' : 'LC') : 'Regular';
				}
				if (species.tier === 'CAP' || species.tier === 'CAP NFE' || species.tier === 'CAP LC') {
					return species.tier;
				}
				if (isDoubles && genNum > 4) {
					return species.doublesTier;
				}
				if (isNatDex || (isPreDLC && genNum === 9.41) || (isSVDLC1 && genNum === 9.411)) {
					return species.natDexTier;
				}
				return species.tier;
			})();
			overrideTier[species.id] = tier;
			if (species.forme) {
				if (
					[
						'Aegislash', 'Castform', 'Cherrim', 'Cramorant', 'Eiscue', 'Meloetta', 'Mimikyu', 'Minior', 'Morpeko', 'Wishiwashi',
					].includes(species.baseSpecies) || species.forme.includes('Totem') || species.forme.includes('Zen') ||
					(species.baseSpecies === 'Ogerpon' && species.forme.includes('Tera'))
				) {
					continue;
				}
			}

			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);

			if (genNum === 9) {
				const ubersUU = Dex.formats.get(gen + 'ubersuu');
				if (ubersUU.exists && Dex.formats.getRuleTable(ubersUU).isBannedSpecies(species)) {
					ubersUUBans[species.id] = 1;
				}
				const mono = Dex.formats.get(gen + (isNatDex ? 'nationaldex' : '') + 'monotype');
				if (Dex.formats.getRuleTable(mono).isBannedSpecies(species)) {
					monotypeBans[species.id] = 1;
				}
			}
		}

		const SanctifiedFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9sanctified/formats-data.js').FormatsData;
		for (const id of SanctifiedPokemon) {
			let species = null;
			try {
				species = DawnDex.mod('gen9sanctified').species.get(id);
			} catch (e) {
				if (invalidSanctifiedSpecies.includes(id)) continue;
				console.log(id);
				invalidSanctifiedSpecies.push(id);
				continue;
			}
			if (!isSanctified) continue;
			let tier = 'Illegal';
			const entry = SanctifiedFormatsData[id];
			if (entry && entry.natDexTier && typeof entry.natDexTier === "string") {
				tier = entry.natDexTier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}
		const UniversalFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9universal/formats-data.js').FormatsData;
		for (const id of UniversalPokemon) {
			const species = DawnDex.mod('gen9universal').species.get(id);
			if (!isUniversal) continue;
			let tier = species.tier;
			const entry = UniversalFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}

		const OmnifieldFormatsData = requireNoCache(dawnPath + 'dist/data/mods/omnifield/formats-data.js').FormatsData;
		for (const id of OmnifieldPokemon) {
			const species = DawnDex.mod('omnifield').species.get(id);
			if (!isOmnifield) continue;
			let tier =  species.natDexTier || species.tier || 'OU';
			const entry = OmnifieldFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.natDexTier || entry.tier || "OU";
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}

		const EspionageFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9espionage/formats-data.js').FormatsData;
		for (const id of EspionagePokemon) {
			const species = DawnDex.mod('gen9espionage').species.get(id);
			if (!isEspionage) continue;
			let tier = species.tier;
			const entry = EspionageFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}

		const RebalancedFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9rebalanced/formats-data.js').FormatsData;
		for (const id of RebalancedPokemon) {
			const species = DawnDex.mod('gen9rebalanced').species.get(id);
			if (!isRebalanced) continue;
			let tier = species.tier;
			const entry = RebalancedFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}

		const GPTFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9gpt/formats-data.js').FormatsData;
		for (const id of GPTPokemon) {
			const species = DawnDex.mod('gen9gpt').species.get(id);
			if (!isGPT) continue;
			let tier = species.tier;
			const entry = GPTFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}
		
		const XenoverseFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen5Xenoverse/formats-data.js').FormatsData;
		for (const id of Object.keys(XenoverseFormatsData)) {
			const species = DawnDex.mod('gen5Xenoverse').species.get(id);
			if (!isXenoverse) continue;
			let tier = 'Illegal';
			const entry = XenoverseFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}
		
		const BlazingFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen6blazing/formats-data.js').FormatsData;
		for (const id of Object.keys(BlazingFormatsData)) {
			const species = DawnDex.mod('gen6blazing').species.get(id);
			if (!isBlazing) continue;
			let tier = 'Illegal';
			const entry = BlazingFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}
		
		const InfinityFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen6infinity/formats-data.js').FormatsData;
		for (const id of Object.keys(InfinityFormatsData)) {
			const species = DawnDex.mod('gen6infinity').species.get(id);
			if (!isInfinity) continue;
			let tier = 'Illegal';
			const entry = InfinityFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}
		
		const DaybreakFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen7daybreak/formats-data.js').FormatsData;
		for (const id of Object.keys(DaybreakFormatsData)) {
			const species = DawnDex.mod('gen7daybreak').species.get(id);
			if (!isDaybreak) continue;
			let tier = 'Illegal';
			const entry = DaybreakFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}
		
		const UntamedFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen8untamed/formats-data.js').FormatsData;
		for (const id of Object.keys(UntamedFormatsData)) {
			const species = DawnDex.mod('gen8untamed').species.get(id);
			if (!isUntamed) continue;
			let tier = 'Illegal';
			const entry = UntamedFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}
		
		let ThirtyFivePokesFormatsData = requireNoCache(dawnPath + 'dist/data/mods/35_pokes/formats-data.js').FormatsData;
		for (const id of Object.keys(ThirtyFivePokesFormatsData)) {
			const species = DawnDex.mod('35_pokes').species.get(id);
			if (!is35Pokes) continue;
			let tier = "Illegal"
			const entry = ThirtyFivePokesFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}

		const SpizzlesFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen5spizzles/formats-data.js').FormatsData;
		for (const id of Object.keys(SpizzlesFormatsData)) {
			const species = DawnDex.mod('gen5spizzles').species.get(id);
			if (!isSpizzles) continue;
			let tier = 'Illegal';
			const entry = SpizzlesFormatsData[id];
			if (entry && entry.tier && typeof entry.tier === "string") {
				tier = entry.tier;
			}
			overrideTier[species.id] = tier;
			if (!tierTable[tier]) tierTable[tier] = [];
			tierTable[tier].push(id);
		}
		if (isSpizzles) {
			const allowedPokemon = new Set([
			  "crobat", "golbat", "zubat", "raichu", "pikachu", "pichu", "nidoqueen",
			  "nidorina", "nidoranf", "hypno", "drowzee", "muk", "grimer", "kabutops",
			  "kabuto", "vileplume", "gloom", "oddish", "wigglytuff", "jigglypuff",
			  "igglybuff", "golem", "graveler", "geodude", "jynx", "smoochum", "hitmonchan",
			  "tyrogue", "charizard", "charmeleon", "charmander", "kadabra", "abra",
			  "quagsire", "wooper", "machamp", "machoke", "machop", "swellow", "taillow",
			  "dustox", "cascoon", "wurmple", "pelipper", "wingull", "solrock", "spinda",
			  "electrode", "voltorb", "castform", "absol", "wobbuffet", "wynaut", "altaria",
			  "swablu", "fearow", "spearow", "arbok", "ekans", "arcanine", "growlithe",
			  "treecko", "seaking", "goldeen", "lunatone", "mightyena", "poochyena",
			  "ludicolo", "lombre", "lotad", "volbeat", "parasect", "paras", "porygon2",
			  "porygon", "camerupt", "numel", "swalot", "gulpin", "beautifly", "silcoon",
			  "aggron", "lairon", "aron", "dusclops", "duskull", "manectric", "electrike",
			  "exploud", "loudred", "whismur", "vespiquen", "combee", "weavile", "sneasel",
			  "ambipom", "aipom", "meganium", "bayleef", "chikorita", "tentacruel",
			  "tentacool", "victreebel", "weepinbell", "bellsprout", "slowking", "slowpoke",
			  "weezing", "koffing", "sandslash", "sandshrew", "lanturn", "chinchou",
			  "tangrowth", "tangela", "xatu", "natu", "ariados", "spinarak", "bellossom",
			  "poliwrath", "poliwhirl", "poliwag", "raticate", "rattata", "girafarig",
			  "exeggutor", "exeggcute", "dragonite", "dragonair", "dratini", "dewgong",
			  "seel", "lickilicky", "lickitung", "grotle", "turtwig", "chingling",
			  "chimecho", "floatzel", "buizel", "lopunny", "buneary", "mimejr", "mrmime",
			  "cherrim", "cherubi", "kricketune", "kricketot", "bibarel", "bidoof",
			  "luxray", "luxio", "shinx", "rapidash", "ponyta", "gastrodon", "shellos",
			  "dodrio", "doduo", "medicham", "meditite", "espeon", "eevee", "pachirisu",
			  "steelix", "onix", "sunkern", "pineco", "ditto", "staraptor", "staravia",
			  "starly", "stantler", "mamoswine", "piloswine", "swinub", "venomoth",
			  "venonat", "ninetales", "vulpix", "sudowoodo", "bonsly", "golduck",
			  "psyduck", "heracross", "serperior", "servine", "snivy", "herdier",
			  "lillipup", "liepard", "purrloin", "simipour", "panpour", "unfezant",
			  "tranquill", "pidove", "gigalith", "boldore", "roggenrola", "woobat",
			  "conkeldurr", "gurdurr", "timburr", "seismitoad", "palpitoad", "tympole",
			  "sandile", "cinccino", "minccino", "gothorita", "gothita", "swanna",
			  "ducklett", "deerling", "accelgor", "shelmet", "mienshao", "mienfoo",
			  "emboar", "pignite", "tepig", "watchog", "patrat", "simisage", "pansage",
			  "munna", "zebstrika", "blitzle", "drilbur", "garbodor", "trubbish",
			  "duosion", "solosis", "vanillish", "vanillite", "emolga", "escavalier",
			  "karrablast", "jellicent", "frillish", "chandelure", "lampent", "litwick",
			  "audino", "rhyhorn", "rhydon", "rhyperior", "dunsparce", "frosmoth", "snom",
			  "rotom", "tropius"
			]);
		  
			// Make sure the 'Illegal' tier exists
			if (!tierTable["Illegal"]) {
			  tierTable["Illegal"] = [];
			}
		  
			// Iterate through each tier (except 'Illegal') and move any PokÃ©mon that are not allowed.
			for (const tier in tierTable) {
			  if (tier === "Illegal") continue; // Skip the Illegal tier itself
		  
			  // Loop backward so that removing elements doesn't affect the iteration
			  for (let i = tierTable[tier].length - 1; i >= 0; i--) {
				const id = tierTable[tier][i];
				if (!allowedPokemon.has(id)) {
				  // Remove from the current tier
				  tierTable[tier].splice(i, 1);
				  // Add to the 'Illegal' tier
				  tierTable["Illegal"].push(id);
				}
			  }
			}
		  }
		  

		nonstandardMoves.push(...Object.keys(Dex.data.Moves).filter(id => {
			const move = Dex.mod(isSSDLC1 ? 'gen8dlc1' : isPreDLC ? 'gen9predlc' : 'gen9dlc1').moves.get(id);
			const bMove = Dex.mod(isSSDLC1 ? 'gen8' : 'gen9').moves.get(id);
			return bMove.isNonstandard !== move.isNonstandard;
		}));

		const tiers = [];
		const items = [];
		const formatSlices = {};

		if (isNatDex || (isPreDLC && genNum === 9.41) || (isSVDLC1 && genNum === 9.411)) {
			BattleTeambuilderTable['gen' + genNum + 'natdex'] = {};
			BattleTeambuilderTable['gen' + genNum + 'natdex'].tiers = tiers;
			BattleTeambuilderTable['gen' + genNum + 'natdex'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen' + genNum + 'natdex'].items = items;
			BattleTeambuilderTable['gen' + genNum + 'natdex'].monotypeBans = monotypeBans;
			BattleTeambuilderTable['gen' + genNum + 'natdex'].formatSlices = formatSlices;
		} else if (isMetBattle) {
			BattleTeambuilderTable[gen + 'metronome'] = {};
			BattleTeambuilderTable[gen + 'metronome'].tiers = tiers;
			BattleTeambuilderTable[gen + 'metronome'].items = items;
			BattleTeambuilderTable[gen + 'metronome'].formatSlices = formatSlices;
		} else if (isNFE) {
			BattleTeambuilderTable[gen + 'nfe'] = {};
			BattleTeambuilderTable[gen + 'nfe'].tiers = tiers;
			BattleTeambuilderTable[gen + 'nfe'].overrideTier = overrideTier;
			BattleTeambuilderTable[gen + 'nfe'].formatSlices = formatSlices;
		} else if (isLC) {
			BattleTeambuilderTable[gen + 'lc'] = {};
			BattleTeambuilderTable[gen + 'lc'].tiers = tiers;
			BattleTeambuilderTable[gen + 'lc'].overrideTier = overrideTier;
			BattleTeambuilderTable[gen + 'lc'].formatSlices = formatSlices;
		} else if (isLetsGo) {
			BattleTeambuilderTable['gen7letsgo'] = {};
			BattleTeambuilderTable['gen7letsgo'].learnsets = {};
			BattleTeambuilderTable['gen7letsgo'].tiers = tiers;
			BattleTeambuilderTable['gen7letsgo'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen7letsgo'].formatSlices = formatSlices;
		} else if (isBDSP && !isDoubles) {
			BattleTeambuilderTable['gen8bdsp'] = {};
			BattleTeambuilderTable['gen8bdsp'].learnsets = {};
			BattleTeambuilderTable['gen8bdsp'].tiers = tiers;
			BattleTeambuilderTable['gen8bdsp'].items = items;
			BattleTeambuilderTable['gen8bdsp'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen8bdsp'].monotypeBans = monotypeBans;
			BattleTeambuilderTable['gen8bdsp'].formatSlices = formatSlices;
		} else if (isOmnifield) {
			BattleTeambuilderTable['omnifield'] = {};
			BattleTeambuilderTable['omnifield'].learnsets = {};
			BattleTeambuilderTable['omnifield'].items = items;
			BattleTeambuilderTable['omnifield'].tiers = tiers;
			BattleTeambuilderTable['omnifield'].overrideTier = overrideTier;
			BattleTeambuilderTable['omnifield'].formatSlices = formatSlices;
		} else if (isEspionage) {
			BattleTeambuilderTable['gen9espionage'] = {};
			BattleTeambuilderTable['gen9espionage'].learnsets = {};
			BattleTeambuilderTable['gen9espionage'].items = items;
			BattleTeambuilderTable['gen9espionage'].tiers = tiers;
			BattleTeambuilderTable['gen9espionage'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen9espionage'].formatSlices = formatSlices;
		} else if (isSanctified) {
			BattleTeambuilderTable['gen9sanctified'] = {};
			BattleTeambuilderTable['gen9sanctified'].learnsets = {};
			BattleTeambuilderTable['gen9sanctified'].items = items;
			BattleTeambuilderTable['gen9sanctified'].tiers = tiers;
			BattleTeambuilderTable['gen9sanctified'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen9sanctified'].formatSlices = formatSlices;
		} else if (isRebalanced) {
			BattleTeambuilderTable['gen9rebalanced'] = {};
			BattleTeambuilderTable['gen9rebalanced'].learnsets = {};
			BattleTeambuilderTable['gen9rebalanced'].items = items;
			BattleTeambuilderTable['gen9rebalanced'].tiers = tiers;
			BattleTeambuilderTable['gen9rebalanced'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen9rebalanced'].formatSlices = formatSlices;
		} else if (isUniversal) {
			BattleTeambuilderTable['gen9universal'] = {};
			BattleTeambuilderTable['gen9universal'].learnsets = {};
			BattleTeambuilderTable['gen9universal'].items = items;
			BattleTeambuilderTable['gen9universal'].tiers = tiers;
			BattleTeambuilderTable['gen9universal'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen9universal'].formatSlices = formatSlices;
		} else if (isGPT) {
			BattleTeambuilderTable['gen9gpt'] = {};
			BattleTeambuilderTable['gen9gpt'].learnsets = {};
			BattleTeambuilderTable['gen9gpt'].items = items;
			BattleTeambuilderTable['gen9gpt'].tiers = tiers;
			BattleTeambuilderTable['gen9gpt'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen9gpt'].formatSlices = formatSlices;
		} else if (is35Pokes) {
			BattleTeambuilderTable['35_pokes'] = {};
			BattleTeambuilderTable['35_pokes'].learnsets = {};
			BattleTeambuilderTable['35_pokes'].items = items;
			BattleTeambuilderTable['35_pokes'].tiers = tiers;
			BattleTeambuilderTable['35_pokes'].overrideTier = overrideTier;
			BattleTeambuilderTable['35_pokes'].formatSlices = formatSlices;
		} else if (isXenoverse) {
			BattleTeambuilderTable['gen5Xenoverse'] = {};
			BattleTeambuilderTable['gen5Xenoverse'].learnsets = {};
			BattleTeambuilderTable['gen5Xenoverse'].items = items;
			BattleTeambuilderTable['gen5Xenoverse'].tiers = tiers;
			BattleTeambuilderTable['gen5Xenoverse'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen5Xenoverse'].formatSlices = formatSlices;
		} else if (isBlazing) {
			BattleTeambuilderTable['gen6blazing'] = {};
			BattleTeambuilderTable['gen6blazing'].learnsets = {};
			BattleTeambuilderTable['gen6blazing'].items = items;
			BattleTeambuilderTable['gen6blazing'].tiers = tiers;
			BattleTeambuilderTable['gen6blazing'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen6blazing'].formatSlices = formatSlices;
		} else if (isInfinity) {
			BattleTeambuilderTable['gen6infinity'] = {};
			BattleTeambuilderTable['gen6infinity'].learnsets = {};
			BattleTeambuilderTable['gen6infinity'].items = items;
			BattleTeambuilderTable['gen6infinity'].tiers = tiers;
			BattleTeambuilderTable['gen6infinity'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen6infinity'].formatSlices = formatSlices;
		} else if (isDaybreak) {
			BattleTeambuilderTable['gen7daybreak'] = {};
			BattleTeambuilderTable['gen7daybreak'].learnsets = {};
			BattleTeambuilderTable['gen7daybreak'].items = items;
			BattleTeambuilderTable['gen7daybreak'].tiers = tiers;
			BattleTeambuilderTable['gen7daybreak'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen7daybreak'].formatSlices = formatSlices;
		} else if (isUntamed) {
			BattleTeambuilderTable['gen8untamed'] = {};
			BattleTeambuilderTable['gen8untamed'].learnsets = {};
			BattleTeambuilderTable['gen8untamed'].items = items;
			BattleTeambuilderTable['gen8untamed'].tiers = tiers;
			BattleTeambuilderTable['gen8untamed'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen8untamed'].formatSlices = formatSlices;
		} else if (isSpizzles) {
			BattleTeambuilderTable['gen5spizzles'] = {};
			BattleTeambuilderTable['gen5spizzles'].learnsets = {};
			BattleTeambuilderTable['gen5spizzles'].items = items;
			BattleTeambuilderTable['gen5spizzles'].tiers = tiers;
			BattleTeambuilderTable['gen5spizzles'].overrideTier = overrideTier;
			BattleTeambuilderTable['gen5spizzles'].formatSlices = formatSlices;
		}  else if (isVGC) {
			BattleTeambuilderTable[gen + 'vgc'] = {};
			BattleTeambuilderTable[gen + 'vgc'].tiers = tiers;
			BattleTeambuilderTable[gen + 'vgc'].formatSlices = formatSlices;
		} else if (isDoubles) {
			BattleTeambuilderTable[gen + 'doubles'] = {};
			BattleTeambuilderTable[gen + 'doubles'].tiers = tiers;
			BattleTeambuilderTable[gen + 'doubles'].overrideTier = overrideTier;
			BattleTeambuilderTable[gen + 'doubles'].formatSlices = formatSlices;
		} else if (isGen9BH) {
			BattleTeambuilderTable['bh'] = {};
			BattleTeambuilderTable['bh'].tiers = tiers;
			BattleTeambuilderTable['bh'].overrideTier = overrideTier;
			BattleTeambuilderTable['bh'].formatSlices = formatSlices;
		} else if (gen === 'gen9') {
			BattleTeambuilderTable.tiers = tiers;
			BattleTeambuilderTable.items = items;
			BattleTeambuilderTable.overrideTier = overrideTier;
			BattleTeambuilderTable.ubersUUBans = ubersUUBans;
			BattleTeambuilderTable.monotypeBans = monotypeBans;
			BattleTeambuilderTable.formatSlices = formatSlices;
		} else {
			BattleTeambuilderTable[gen] = {};
			BattleTeambuilderTable[gen].overrideTier = overrideTier;
			BattleTeambuilderTable[gen].tiers = tiers;
			BattleTeambuilderTable[gen].items = items;
			BattleTeambuilderTable[gen].formatSlices = formatSlices;
			if (genNum >= 5) {
				BattleTeambuilderTable[gen].monotypeBans = monotypeBans;
			}
			if (isSSDLC1 || isPreDLC || isSVDLC1 || is35Pokes) {
				BattleTeambuilderTable[gen].nonstandardMoves = nonstandardMoves;
				BattleTeambuilderTable[gen].learnsets = {};
			}
		}

		const tierOrder = (() => {
			if (is35Pokes) {
				return ["Permitted"]
			}
			if (isSanctified || isUniversal || isRebalanced || isGPT || isXenoverse || isBlazing || isInfinity || isDaybreak || isUntamed) {
				return ["AG", "Uber", "(Uber)", "OUBL", "OU", "(OU)", "UUBL", "UU", "RUBL", "RU", 'HUBL', 'HU', "NUBL", "NU", "AUBL", "AU", "PUBL", "PU", "ZUBL", "ZU", "FUBL", "FU", "NFE", "LC"];
			}
			if (isVGC || isGen9BH) {
				return ["Mythical", "Restricted Legendary", "Regular", "NFE", "LC"];
			}
			if (isDoubles && genNum > 4) {
				return ["DUber", "(DUber)", "DOU", "DBL", "(DOU)", "DUU", "(DUU)", "New", "NFE", "LC"];
			}
			if (gen === 'gen4') {
				return ["CAP", "CAP NFE", "CAP LC", "AG", "Uber", "OU", "(OU)", "UUBL", "UU", "NUBL", "NU", "NFE", "LC"];
			}
			return ["CAP", "CAP NFE", "CAP LC", "AG", "Uber", "(Uber)", "OU", "(OU)", "UUBL", "UU", "RUBL", "RU", "NUBL", "NU", "PUBL", "PU", "ZUBL", "ZU", "New", "NFE", "LC", "Unreleased"];
		})();

		for (const tier of tierOrder) {
			if (tier in {OUBL: 1, OU:1, AG:1, Uber:1, UU:1, RU:1, HUBL:1, HU:1, NU:1, AUBL:1, AU:1, PU:1, ZU: 1, FUBL:1, FU:1, NFE:1, LC:1, DOU:1, DUU:1, "(DUU)":1, New:1, Legal:1, Regular:1, "Restricted Legendary":1, "CAP LC":1, "Permitted":1}) {
				let usedTier = tier;
				if (usedTier === "(DUU)") usedTier = "DNU";
				formatSlices[usedTier] = tiers.length;
			}
			if (!tierTable[tier]) continue;
			if (tier === "(PU)") {
				tiers.push(['header', "Below PU"]);
			} else if (tier === "(DUU)") {
				tiers.push(['header', "Below DUU"]);
			} else if (tier.charAt(0) === '(') {
				tiers.push(['header', tier.slice(1, -1) + " by technicality"]);
			} else if (tier === "NFE") {
				tiers.push(['header', "NFEs not in a higher tier"]);
			} else {
				tiers.push(['header', tier]);
			}
			tiers.push(...tierTable[tier]);
		}
		if (!isDoubles) {
			if (!formatSlices['OU']) formatSlices['OU'] = formatSlices['New'];
			if (!formatSlices['UU']) formatSlices['UU'] = formatSlices['New'];
			if (!formatSlices['RU']) formatSlices['RU'] = formatSlices['New'];
		} else {
			if (!formatSlices['DOU']) formatSlices['DOU'] = formatSlices['New'];
			if (!formatSlices['DUU']) formatSlices['DUU'] = formatSlices['New'];
		}

		const itemList = Object.keys(Dex.data.Items);
		itemList.sort();

		const greatItems = [['header', "Popular items"]];
		const goodItems = [['header', "Items"]];
		const specificItems = [['header', "Pok&eacute;mon-specific items"]];
		const poorItems = [['header', "Usually useless items"]];
		const badItems = [['header', "Useless items"]];
		const unreleasedItems = [];
		if (genNum === 6) unreleasedItems.push(['header', "Unreleased"]);
		for (const id of itemList) {
			const item = Dex.mod(gen).items.get(id);
			if (item.gen > genNum) {
				continue;
			}
			if (item.isNonstandard && !isMetBattle) {
				if (isNatDex || isSanctified || isOmnifield || isUniversal || isEspionage || isRebalanced || isGPT || is35Pokes || isXenoverse || isBlazing || isInfinity || isDaybreak || isUntamed) {
					let curItem = item;
					let curGen = genNum;
					while (item.isNonstandard && curGen >= 7) {
						curItem = Dex.forGen(curGen).items.get(item.id);
						curGen--;
					}
					if (curItem.isNonstandard) continue;
				} else if (genNum !== 2) {
					continue;
				}
			}
			if (isMetBattle) {
				const banlist = Dex.formats.getRuleTable(Dex.formats.get(gen + 'metronomebattle'));
				if (banlist.isBanned('item:' + item.id)) continue;
			}
			switch (id) {
			case 'leftovers':
			case 'lifeorb':
			case 'choiceband':
			case 'choicescarf':
			case 'choicespecs':
			case 'eviolite':
			case 'assaultvest':
			case 'focussash':
			case 'powerherb':
			case 'rockyhelmet':
			case 'heavydutyboots':
			case 'expertbelt':
			case 'salacberry':
				greatItems.push(id);
				break;
			case 'mentalherb':
				if (genNum > 4) greatItems.push(id);
				else poorItems.push(id);
				break;
			case 'lumberry':
				if (genNum === 2 || genNum > 6) goodItems.push(id);
				else greatItems.push(id);
				break;
			case 'sitrusberry':
				if (genNum > 6) goodItems.push(id);
				else if (genNum > 3 && genNum < 7) greatItems.push(id);
				else poorItems.push(id);
				break;
			case 'aguavberry':
			case 'figyberry':
			case 'iapapaberry':
			case 'magoberry':
			case 'wikiberry':
				if (genNum >= 7) greatItems.push(id);
				else poorItems.push(id);
				break;
			case 'berryjuice':
				if (genNum === 2) poorItems.push(id);
				else goodItems.push(id);
				break;
			case 'dragonfang':
				if (genNum === 2) badItems.push(id);
				else goodItems.push(id);
				break;
			case 'dragonscale':
				if (genNum === 2) goodItems.push(id);
				else badItems.push(id);
				break;
			case 'mail':
				if (genNum >= 6) unreleasedItems.push(id);
				else goodItems.push(id);
				break;
			// Legendaries
			case 'adamantorb':
			case 'griseousorb':
			case 'lustrousorb':
			case 'blueorb':
			case 'redorb':
			case 'souldew':
			// Other
			// fallsthrough
			case 'stick':
			case 'thickclub':
			case 'lightball':
			case 'luckypunch':
			case 'quickpowder':
			case 'metalpowder':
			case 'deepseascale':
			case 'deepseatooth':
				specificItems.push(id);
				break;
			// Fling-only
			case 'rarebone':
			case 'belueberry':
			case 'blukberry':
			case 'cornnberry':
			case 'durinberry':
			case 'hondewberry':
			case 'magostberry':
			case 'nanabberry':
			case 'nomelberry':
			case 'pamtreberry':
			case 'pinapberry':
			case 'pomegberry':
			case 'qualotberry':
			case 'rabutaberry':
			case 'razzberry':
			case 'spelonberry':
			case 'tamatoberry':
			case 'watmelberry':
			case 'wepearberry':
			case 'energypowder':
			case 'electirizer':
			case 'oldamber':
			case 'dawnstone':
			case 'dubiousdisc':
			case 'duskstone':
			case 'firestone':
			case 'icestone':
			case 'leafstone':
			case 'magmarizer':
			case 'moonstone':
			case 'ovalstone':
			case 'prismscale':
			case 'protector':
			case 'reapercloth':
			case 'sachet':
			case 'shinystone':
			case 'sunstone':
			case 'thunderstone':
			case 'upgrade':
			case 'waterstone':
			case 'whippeddream':
			case 'bottlecap':
			case 'goldbottlecap':
			case 'galaricacuff':
			case 'chippedpot':
			case 'crackedpot':
			case 'galaricawreath':
				badItems.push(id);
				break;
			// outclassed items
			case 'aspearberry':
			case 'bindingband':
			case 'cheriberry':
			case 'destinyknot':
			case 'enigmaberry':
			case 'floatstone':
			case 'ironball':
			case 'jabocaberry':
			case 'oranberry':
			case 'machobrace':
			case 'pechaberry':
			case 'persimberry':
			case 'poweranklet':
			case 'powerband':
			case 'powerbelt':
			case 'powerbracer':
			case 'powerlens':
			case 'powerweight':
			case 'rawstberry':
			case 'ringtarget':
			case 'rowapberry':
			case 'bigroot':
			case 'focusband':
			// gen 2
			case 'psncureberry':
			case 'przcureberry':
			case 'burntberry':
			case 'bitterberry':
			case 'iceberry':
			case 'berry':
				poorItems.push(id);
				break;
			default:
				if (
					item.name.endsWith(" Ball") || item.name.endsWith(" Fossil") || item.name.startsWith("Fossilized ") ||
					item.name.endsWith(" Sweet") || item.name.endsWith(" Apple")
				) {
					badItems.push(id);
				} else if (item.name.startsWith("TR")) {
					badItems.push(id);
				} else if (item.name.endsWith(" Gem") && item.name !== "Normal Gem") {
					if (genNum >= 6) {
						unreleasedItems.push(id);
					} else if (item.name === "Flying Gem") {
						greatItems.push(id);
					} else {
						goodItems.push(id);
					}
				} else if (item.name.endsWith(" Drive")) {
					specificItems.push(id);
				} else if (item.name.endsWith(" Memory")) {
					specificItems.push(id);
				} else if (item.name.startsWith("Rusted")) {
					specificItems.push(id);
				} else if (item.itemUser) {
					specificItems.push(id);
				} else if (item.megaStone) {
					specificItems.push(id);
				} else {
					goodItems.push(id);
				}
			}
		}
		const EspionageItemList = Object.keys(DawnDex.mod('gen9espionage').data.Items);
		const SanctifiedItemList = Object.keys(DawnDex.mod('gen9sanctified').data.Items);
		const UniversalItemList = Object.keys(DawnDex.mod('gen9universal').data.Items);
		const OmnifieldItemList = Object.keys(DawnDex.mod('omnifield').data.Items);
		const RebalancedItemList = Object.keys(DawnDex.mod('gen9rebalanced').data.Items);
		const GPTItemList = Object.keys(DawnDex.mod('gen9gpt').data.Items);
		const XenoverseItemList = Object.keys(DawnDex.mod('gen5Xenoverse').data.Items);
		const BlazingItemList = Object.keys(DawnDex.mod('gen6blazing').data.Items);
		const IninfinityItemList = Object.keys(DawnDex.mod('gen6infinity').data.Items);
		const DaybreakItemList = Object.keys(DawnDex.mod('gen7daybreak').data.Items);
		const UntamedItemList = Object.keys(DawnDex.mod('gen8untamed').data.Items);
		EspionageItemList.sort();
		SanctifiedItemList.sort();
		UniversalItemList.sort();
		OmnifieldItemList.sort();
		RebalancedItemList.sort();
		GPTItemList.sort();
		XenoverseItemList.sort();
		BlazingItemList.sort();
		IninfinityItemList.sort();
		DaybreakItemList.sort();
		UntamedItemList.sort();
		for (const id of EspionageItemList) {
			if (itemList.includes(id)) continue;
			if (!isEspionage) continue;
			greatItems.push(id);
		}
		for (const id of SanctifiedItemList) {
			if (itemList.includes(id)) continue;
			if (!isSanctified) continue;
			greatItems.push(id);
		}
		for (const id of UniversalItemList) {
			if (itemList.includes(id)) continue;
			if (!isUniversal) continue;
			greatItems.push(id);
		}
		for (const id of OmnifieldItemList) {
			if (itemList.includes(id)) continue;
			if (!isOmnifield) continue;
			greatItems.push(id);
		}
		for (const id of RebalancedItemList) {
			if (itemList.includes(id)) continue;
			if (!isRebalanced) continue;
			greatItems.push(id);
		}
		for (const id of GPTItemList) {
			if (itemList.includes(id)) continue;
			if (!isGPT) continue;
			greatItems.push(id);
		}
		for (const id of XenoverseItemList) {
			if (itemList.includes(id)) continue;
			if (!isXenoverse) continue;
			greatItems.push(id);
		}
		for (const id of BlazingItemList) {
			if (itemList.includes(id)) continue;
			if (!isBlazing) continue;
			greatItems.push(id);
		}
		for (const id of IninfinityItemList) {
			if (itemList.includes(id)) continue;
			if (!isInfinity) continue;
			greatItems.push(id);
		}
		for (const id of DaybreakItemList) {
			if (itemList.includes(id)) continue;
			if (!isDaybreak) continue;
			greatItems.push(id);
		}
		for (const id of UntamedItemList) {
			if (itemList.includes(id)) continue;
			if (!isUntamed) continue;
			greatItems.push(id);
		}
		items.push(...greatItems);
		items.push(...goodItems);
		items.push(...specificItems);
		items.push(...poorItems);
		items.push(...badItems);
		items.push(...unreleasedItems);
	}

	//
	// Learnset table
	//

	const gen3HMs = new Set(['cut', 'fly', 'surf', 'strength', 'flash', 'rocksmash', 'waterfall', 'dive']);
	const gen4HMs = new Set(['cut', 'fly', 'surf', 'strength', 'rocksmash', 'waterfall', 'rockclimb']);

	const learnsets = {};
	BattleTeambuilderTable.learnsets = learnsets;
	for (const id in Dex.data.Learnsets) {
		const learnset = Dex.data.Learnsets[id].learnset;
		if (!learnset) continue;
		learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);

			if (minGen <= 4 && (gen3HMs.has(moveid) || gen4HMs.has(moveid))) {
				let legalGens = '';
				let available = false;

				if (minGen === 3) {
					legalGens += '3';
					available = true;
				}
				if (available) available = !gen3HMs.has(moveid);

				if (available || gens.includes(4)) {
					legalGens += '4';
					available = true;
				}
				if (available) available = !gen4HMs.has(moveid);

				let minUpperGen = available ? 5 : Math.min(
					...gens.filter(gen => gen > 4)
				);
				legalGens += '0123456789'.slice(minUpperGen);
				learnsets[id][moveid] = legalGens;
			} else {
				learnsets[id][moveid] = '0123456789'.slice(minGen);
			}

			if (gens.indexOf(6) >= 0) learnsets[id][moveid] += 'p';
			if (gens.indexOf(7) >= 0 && learnset[moveid].some(x => x[0] === '7' && x !== '7V')) {
				learnsets[id][moveid] += 'q';
			}
			if (gens.indexOf(8) >= 0 && learnset[moveid].some(x => x[0] === '8' && x !== '8V')) {
				learnsets[id][moveid] += 'g';
			}
			if (gens.indexOf(9) >= 0 && learnset[moveid].some(x => x[0] === '9' && x !== '9V')) {
				learnsets[id][moveid] += 'a';
			}
		}
	}
	const G2Learnsets = Dex.mod('gen2').data.Learnsets;
	for (const id in G2Learnsets) {
		const learnset = G2Learnsets[id].learnset;
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			if (!learnsets[id]) {
				throw new Error(`${id} has a Gen 2 learnset but not a modern learnset`);
			}
			if (!learnsets[id][moveid]) learnsets[id][moveid] = '';
			if (minGen === 2) learnsets[id][moveid] = '2' + learnsets[id][moveid];
			if (minGen === 1) learnsets[id][moveid] = '12' + learnsets[id][moveid];
		}
	}
	const LGLearnsets = Dex.mod('gen7letsgo').data.Learnsets;
	for (const id in LGLearnsets) {
		const species = Dex.mod('gen7letsgo').species.get(id);
		const baseSpecies = Dex.mod('gen7letsgo').species.get(species.baseSpecies);
		const validNum = (baseSpecies.num <= 151 && baseSpecies.num >= 1) || [808, 809].includes(baseSpecies.num);
		if (!validNum) continue;
		if (species.forme && !['Alola', 'Mega', 'Mega-X', 'Mega-Y', 'Starter'].includes(species.forme)) continue;
		const learnset = LGLearnsets[id].learnset;
		BattleTeambuilderTable['gen7letsgo'].learnsets[id] = {};
		for (const moveid in learnset) {
			BattleTeambuilderTable['gen7letsgo'].learnsets[id][moveid] = '7';
		}
	}
	const BDSPLearnsets = Dex.mod('gen8bdsp').data.Learnsets;
	for (const id in BDSPLearnsets) {
		const species = Dex.mod('gen8bdsp').species.get(id);
		if (species.isNonstandard && !['Unobtainable', 'CAP'].includes(species.isNonstandard)) continue;
		const learnset = BDSPLearnsets[id].learnset;
		BattleTeambuilderTable['gen8bdsp'].learnsets[id] = {};
		for (const moveid in learnset) {
			BattleTeambuilderTable['gen8bdsp'].learnsets[id][moveid] = '8g';
		}
	}
	const SSDLC1Learnsets = Dex.mod('gen8dlc1').data.Learnsets;
	for (const id in SSDLC1Learnsets) {
		const learnset = SSDLC1Learnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen8dlc1'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);

			if (minGen <= 4 && (gen3HMs.has(moveid) || gen4HMs.has(moveid))) {
				let legalGens = '';
				let available = false;

				if (minGen === 3) {
					legalGens += '3';
					available = true;
				}
				if (available) available = !gen3HMs.has(moveid);

				if (available || gens.includes(4)) {
					legalGens += '4';
					available = true;
				}
				if (available) available = !gen4HMs.has(moveid);

				let minUpperGen = available ? 5 : Math.min(
					...gens.filter(gen => gen > 4)
				);
				legalGens += '012345678'.slice(minUpperGen);
				BattleTeambuilderTable['gen8dlc1'].learnsets[id][moveid] = legalGens;
			} else {
				BattleTeambuilderTable['gen8dlc1'].learnsets[id][moveid] = '012345678'.slice(minGen);
			}

			if (gens.indexOf(6) >= 0) BattleTeambuilderTable['gen8dlc1'].learnsets[id][moveid] += 'p';
			if (gens.indexOf(7) >= 0 && learnset[moveid].some(x => x[0] === '7' && x !== '7V')) {
				BattleTeambuilderTable['gen8dlc1'].learnsets[id][moveid] += 'q';
			}
			if (gens.indexOf(8) >= 0 && learnset[moveid].some(x => x[0] === '8' && x !== '8V')) {
				BattleTeambuilderTable['gen8dlc1'].learnsets[id][moveid] += 'g';
			}
		}
	}
	const PreDLCLearnsets = Dex.mod('gen9predlc').data.Learnsets;
	for (const id in PreDLCLearnsets) {
		const learnset = PreDLCLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen9predlc'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);

			if (minGen <= 4 && (gen3HMs.has(moveid) || gen4HMs.has(moveid))) {
				let legalGens = '';
				let available = false;

				if (minGen === 3) {
					legalGens += '3';
					available = true;
				}
				if (available) available = !gen3HMs.has(moveid);

				if (available || gens.includes(4)) {
					legalGens += '4';
					available = true;
				}
				if (available) available = !gen4HMs.has(moveid);

				let minUpperGen = available ? 5 : Math.min(
					...gens.filter(gen => gen > 4)
				);
				legalGens += '0123456789'.slice(minUpperGen);
				BattleTeambuilderTable['gen9predlc'].learnsets[id][moveid] = legalGens;
			} else {
				BattleTeambuilderTable['gen9predlc'].learnsets[id][moveid] = '0123456789'.slice(minGen);
			}

			if (gens.indexOf(6) >= 0) BattleTeambuilderTable['gen9predlc'].learnsets[id][moveid] += 'p';
			if (gens.indexOf(7) >= 0 && learnset[moveid].some(x => x[0] === '7' && x !== '7V')) {
				BattleTeambuilderTable['gen9predlc'].learnsets[id][moveid] += 'q';
			}
			if (gens.indexOf(8) >= 0 && learnset[moveid].some(x => x[0] === '8' && x !== '8V')) {
				BattleTeambuilderTable['gen9predlc'].learnsets[id][moveid] += 'g';
			}
			if (gens.indexOf(9) >= 0 && learnset[moveid].some(x => x[0] === '9' && x !== '9V')) {
				BattleTeambuilderTable['gen9predlc'].learnsets[id][moveid] += 'a';
			}
		}
	}
	const SVDLC1Learnsets = Dex.mod('gen9dlc1').data.Learnsets;
	for (const id in SVDLC1Learnsets) {
		const learnset = SVDLC1Learnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen9dlc1'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);

			if (minGen <= 4 && (gen3HMs.has(moveid) || gen4HMs.has(moveid))) {
				let legalGens = '';
				let available = false;

				if (minGen === 3) {
					legalGens += '3';
					available = true;
				}
				if (available) available = !gen3HMs.has(moveid);

				if (available || gens.includes(4)) {
					legalGens += '4';
					available = true;
				}
				if (available) available = !gen4HMs.has(moveid);

				let minUpperGen = available ? 5 : Math.min(
					...gens.filter(gen => gen > 4)
				);
				legalGens += '0123456789'.slice(minUpperGen);
				BattleTeambuilderTable['gen9dlc1'].learnsets[id][moveid] = legalGens;
			} else {
				BattleTeambuilderTable['gen9dlc1'].learnsets[id][moveid] = '0123456789'.slice(minGen);
			}

			if (gens.indexOf(6) >= 0) BattleTeambuilderTable['gen9dlc1'].learnsets[id][moveid] += 'p';
			if (gens.indexOf(7) >= 0 && learnset[moveid].some(x => x[0] === '7' && x !== '7V')) {
				BattleTeambuilderTable['gen9dlc1'].learnsets[id][moveid] += 'q';
			}
			if (gens.indexOf(8) >= 0 && learnset[moveid].some(x => x[0] === '8' && x !== '8V')) {
				BattleTeambuilderTable['gen9dlc1'].learnsets[id][moveid] += 'g';
			}
			if (gens.indexOf(9) >= 0 && learnset[moveid].some(x => x[0] === '9' && x !== '9V')) {
				BattleTeambuilderTable['gen9dlc1'].learnsets[id][moveid] += 'a';
			}
		}
	}

	const SanctifiedLearnsets = DawnDex.mod('gen9sanctified').data.Learnsets;
	for (const id in SanctifiedLearnsets) {
		const learnset = SanctifiedLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen9sanctified'].learnsets[id] = {};
		// just put them in
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			BattleTeambuilderTable['gen9sanctified'].learnsets[id][moveid] = '0123456789'.slice(minGen) + 'a';
		}
	}

	const UniversalLearnsets = DawnDex.mod('gen9universal').data.Learnsets;
	for (const id in UniversalLearnsets) {
		const learnset = UniversalLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen9universal'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			BattleTeambuilderTable['gen9universal'].learnsets[id][moveid] = '0123456789'.slice(minGen) + 'a';
		}
	}

	const OmnifieldLearnsets = DawnDex.mod('omnifield').data.Learnsets;
	for (const id in OmnifieldLearnsets) {
		const learnset = OmnifieldLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['omnifield'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			BattleTeambuilderTable['omnifield'].learnsets[id][moveid] = '0123456789'.slice(minGen) + 'a';
		}
	}

	const EspionageLearnsets = DawnDex.mod('gen9espionage').data.Learnsets;
	for (const id in EspionageLearnsets) {
		const learnset = EspionageLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen9espionage'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			BattleTeambuilderTable['gen9espionage'].learnsets[id][moveid] = '0123456789'.slice(minGen) + 'a';
		}
	}

	const RebalancedLearnsets = DawnDex.mod('gen9rebalanced').data.Learnsets;
	for (const id in RebalancedLearnsets) {
		const learnset = RebalancedLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen9rebalanced'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			BattleTeambuilderTable['gen9rebalanced'].learnsets[id][moveid] = '0123456789'.slice(minGen) + 'a';
		}
	}

	const GPTLearnsets = DawnDex.mod('gen9gpt').data.Learnsets;
	for (const id in GPTLearnsets) {
		const learnset = GPTLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen9gpt'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			BattleTeambuilderTable['gen9gpt'].learnsets[id][moveid] = '0123456789'.slice(minGen) + 'a';
		}
	}

	const BlazingLearnsets = DawnDex.mod('gen6blazing').data.Learnsets;
	for (const id in BlazingLearnsets) {
		const learnset = BlazingLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen6blazing'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			BattleTeambuilderTable['gen6blazing'].learnsets[id][moveid] = '0123456'.slice(minGen) + 'a';
		}
	}

	const InfinityLearnsets = DawnDex.mod('gen6infinity').data.Learnsets;
	for (const id in InfinityLearnsets) {
		const learnset = InfinityLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen6infinity'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			BattleTeambuilderTable['gen6infinity'].learnsets[id][moveid] = '0123456'.slice(minGen) + 'a';
		}
	}

	const UntamedLearnsets = DawnDex.mod('gen8untamed').data.Learnsets;
	for (const id in UntamedLearnsets) {
		const learnset = UntamedLearnsets[id].learnset;
		if (!learnset) continue;
		BattleTeambuilderTable['gen8untamed'].learnsets[id] = {};
		for (const moveid in learnset) {
			const gens = learnset[moveid].map(x => Number(x[0]));
			const minGen = Math.min(...gens);
			BattleTeambuilderTable['gen8untamed'].learnsets[id][moveid] = '012345678'.slice(minGen) + 'a';
		}
	}

	// Client relevant data that should be overriden by past gens and mods
	const overrideSpeciesKeys = ['abilities', 'baseStats', 'cosmeticFormes', 'isNonstandard', 'requiredItems', 'types', 'unreleasedHidden'];
	const overrideMoveKeys = ['accuracy', 'basePower', 'category', 'desc', 'flags', 'isNonstandard', 'noSketch', 'pp', 'priority', 'shortDesc', 'target', 'type'];
	const overrideAbilityKeys = ['desc', 'isNonstandard', 'rating', 'shortDesc'];

	//
	// Past gen table
	//

	for (const genNum of [8, 7, 6, 5, 4, 3, 2, 1]) {
		const gen = 'gen' + genNum;
		const nextGen = 'gen' + (genNum + 1);
		const genDex = Dex.mod(gen);
		const genData = genDex.data;
		const nextGenDex = Dex.mod(nextGen);
		const nextGenData = nextGenDex.data;

		const overrideSpeciesData = {};
		BattleTeambuilderTable[gen].overrideSpeciesData = overrideSpeciesData;
		for (const id in genData.Pokedex) {
			const curEntry = genDex.species.get(id);
			const nextEntry = nextGenDex.species.get(id);
			for (const key of overrideSpeciesKeys) {
				if (JSON.stringify(curEntry[key]) !== JSON.stringify(nextEntry[key])) {
					if (!overrideSpeciesData[id]) overrideSpeciesData[id] = {};
					overrideSpeciesData[id][key] = curEntry[key];
				}
			}
		}

		const overrideMoveData = {};
		BattleTeambuilderTable[gen].overrideMoveData = overrideMoveData;
		for (const id in genData.Moves) {
			const curEntry = genDex.moves.get(id);
			const nextEntry = nextGenDex.moves.get(id);
			for (const key of overrideMoveKeys) {
				if (key === 'category' && genNum <= 3) continue;
				if (JSON.stringify(curEntry[key]) !== JSON.stringify(nextEntry[key])) {
					if (!overrideMoveData[id]) overrideMoveData[id] = {};
					overrideMoveData[id][key] = curEntry[key];
				}
			}
		}

		const overrideAbilityData = {};
		BattleTeambuilderTable[gen].overrideAbilityData = overrideAbilityData;
		for (const id in genData.Abilities) {
			const curEntry = genDex.abilities.get(id);
			const nextEntry = nextGenDex.abilities.get(id);
			for (const key of overrideAbilityKeys) {
				if (JSON.stringify(curEntry[key]) !== JSON.stringify(nextEntry[key])) {
					if (!overrideAbilityData[id]) overrideAbilityData[id] = {};
					overrideAbilityData[id][key] = curEntry[key];
				}
			}
		}

		const overrideItemDesc = {};
		BattleTeambuilderTable[gen].overrideItemDesc = overrideItemDesc;
		for (const id in genData.Items) {
			const curEntry = genDex.items.get(id);
			const nextEntry = nextGenDex.items.get(id);
			if ((curEntry.shortDesc || curEntry.desc) !== (nextEntry.shortDesc || nextEntry.desc)) {
				overrideItemDesc[id] = (curEntry.shortDesc || curEntry.desc);
			}
		}

		const overrideTypeChart = {};
		BattleTeambuilderTable[gen].overrideTypeChart = overrideTypeChart;
		const removeType = {};
		BattleTeambuilderTable[gen].removeType = removeType;
		for (const id in nextGenData.TypeChart) {
			const curEntry = genData.TypeChart[id];
			const nextEntry = nextGenData.TypeChart[id];
			if (curEntry.isNonstandard) {
				removeType[id] = true;
				continue;
			}
			if (JSON.stringify(nextEntry) !== JSON.stringify(curEntry)) {
				overrideTypeChart[id] = curEntry;
			}
		}
	}

	//
	// Mods
	//
	let invalidModSpecies = [];
	for (const mod of ['gen7letsgo', 'gen8bdsp', 'gen9sanctified', 'gen9universal', 'omnifield', 'gen9espionage', 'gen9rebalanced', 'gen9gpt', '35_pokes', 'gen5Xenoverse', 'gen6blazing', 'gen6infinity', 'gen7daybreak', 'gen8untamed', 'gen5spizzles']) {
		const modDex = DawnDex.mod(mod);
		const modData = modDex.data;
		const parentDex = DawnDex.forGen(modDex.gen);

		const overrideSpeciesData = {};
		if (!BattleTeambuilderTable[mod]) BattleTeambuilderTable[mod] = {};
		BattleTeambuilderTable[mod].overrideSpeciesData = overrideSpeciesData;
		for (const id in modData.Pokedex) {
			let modEntry = null;
			try {
				modEntry = modDex.species.get(id);
			} catch(e) {
				if (invalidModSpecies.includes(mod + ':' + id)) continue;
				console.log('mod:')
				console.log(mod);
				console.log('id:');
				console.log(id);
				invalidModSpecies.push(mod + ':' + id);
				continue;
			}
			const parentEntry = parentDex.species.get(id);
			for (const key of overrideSpeciesKeys) {
				if (JSON.stringify(modEntry[key]) !== JSON.stringify(parentEntry[key])) {
					if (!overrideSpeciesData[id]) overrideSpeciesData[id] = {};
					overrideSpeciesData[id][key] = modEntry[key];
				}
			}
		}

		const overrideMoveData = {};
		BattleTeambuilderTable[mod].overrideMoveData = overrideMoveData;
		for (const id in modData.Moves) {
			const modEntry = modDex.moves.get(id);
			const parentEntry = parentDex.moves.get(id);
			for (const key of overrideMoveKeys) {
				if (key === 'category' && modDex.gen <= 3) continue;
				if (JSON.stringify(modEntry[key]) !== JSON.stringify(parentEntry[key])) {
					if (!overrideMoveData[id]) overrideMoveData[id] = {};
					overrideMoveData[id][key] = modEntry[key];
				}
			}
		}

		const overrideAbilityData = {};
		BattleTeambuilderTable[mod].overrideAbilityData = overrideAbilityData;
		for (const id in modData.Abilities) {
			const modEntry = modDex.abilities.get(id);
			const parentEntry = parentDex.abilities.get(id);
			for (const key of overrideAbilityKeys) {
				if (JSON.stringify(modEntry[key]) !== JSON.stringify(parentEntry[key])) {
					if (!overrideAbilityData[id]) overrideAbilityData[id] = {};
					overrideAbilityData[id][key] = modEntry[key];
				}
			}
		}
	}

	buf += `exports.BattleTeambuilderTable = JSON.parse('${JSON.stringify(BattleTeambuilderTable).replace(/['\\]/g, "\\$&")}');\n\n`;

	fs.writeFileSync('play.pokemonshowdown.com/data/teambuilder-tables.js', buf);
}

console.log("DONE");

/*********************************************************
 * Build pokedex.js
 *********************************************************/

process.stdout.write("Building `data/pokedex.js`... ");

{
	let Pokedex = requireNoCache('../caches/pokemon-showdown/dist/data/pokedex.js').Pokedex;
	const SanctifiedDex = requireNoCache(dawnPath + 'dist/data/mods/gen9sanctified/pokedex.js').Pokedex;
	const SanctifiedFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9sanctified/formats-data.js').FormatsData;
	const UniversalDex = requireNoCache(dawnPath + 'dist/data/mods/gen9universal/pokedex.js').Pokedex;
	const UniversalFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9universal/formats-data.js').FormatsData;
	const OmnifieldDex = requireNoCache(dawnPath + 'dist/data/mods/omnifield/pokedex.js').Pokedex;
	const OmnifieldFormatsData = requireNoCache(dawnPath + 'dist/data/mods/omnifield/formats-data.js').FormatsData;
	const EspionageDex = requireNoCache(dawnPath + 'dist/data/mods/gen9espionage/pokedex.js').Pokedex;
	const EspionageFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9espionage/formats-data.js').FormatsData;
	const RebalancedDex = requireNoCache(dawnPath + 'dist/data/mods/gen9rebalanced/pokedex.js').Pokedex;
	const RebalancedFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9rebalanced/formats-data.js').FormatsData;
	const GPTDex = requireNoCache(dawnPath + 'dist/data/mods/gen9gpt/pokedex.js').Pokedex;
	const GPTFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9gpt/formats-data.js').FormatsData;
	const XenoverseDex = requireNoCache(dawnPath + 'dist/data/mods/gen5Xenoverse/pokedex.js').Pokedex;
	const XenoverseFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen5Xenoverse/formats-data.js').FormatsData;
	const BlazingDex = requireNoCache(dawnPath + 'dist/data/mods/gen6blazing/pokedex.js').Pokedex;
	const BlazingFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen6blazing/formats-data.js').FormatsData;
	const InfinityDex = requireNoCache(dawnPath + 'dist/data/mods/gen6infinity/pokedex.js').Pokedex;
	const InfinityFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen6infinity/formats-data.js').FormatsData;
	const DaybreakDex = requireNoCache(dawnPath + 'dist/data/mods/gen7daybreak/pokedex.js').Pokedex;
	const DaybreakFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen7daybreak/formats-data.js').FormatsData;
	const UntamedDex = requireNoCache(dawnPath + 'dist/data/mods/gen8untamed/pokedex.js').Pokedex;
	const UntamedFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen8untamed/formats-data.js').FormatsData;
	DawnDex.data.FormatsData = Object.assign(SanctifiedFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(UniversalFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(OmnifieldFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(EspionageFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(RebalancedFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(GPTFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(XenoverseFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(BlazingFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(InfinityFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(DaybreakFormatsData, DawnDex.data.FormatsData);
	DawnDex.data.FormatsData = Object.assign(UntamedFormatsData, DawnDex.data.FormatsData);
	Pokedex = Object.assign(SanctifiedDex, Pokedex);
	Pokedex = Object.assign(UniversalDex, Pokedex);
	Pokedex = Object.assign(OmnifieldDex, Pokedex);
	Pokedex = Object.assign(EspionageDex, Pokedex);
	Pokedex = Object.assign(RebalancedDex, Pokedex);
	Pokedex = Object.assign(GPTDex, Pokedex);
	Pokedex = Object.assign(XenoverseDex, Pokedex);
	Pokedex = Object.assign(BlazingDex, Pokedex);
	Pokedex = Object.assign(InfinityDex, Pokedex);
	Pokedex = Object.assign(DaybreakDex, Pokedex);
	Pokedex = Object.assign(UntamedDex, Pokedex);
	for (const id in Pokedex) {
		const entry = Pokedex[id];
		if (DawnDex.data.FormatsData[id]) {
			const formatsEntry = DawnDex.data.FormatsData[id];
			if (formatsEntry.tier) entry.tier = formatsEntry.tier;
			if (formatsEntry.tier === 'Illegal') entry.tier = 'OU';
			if (formatsEntry.isNonstandard) entry.isNonstandard = formatsEntry.isNonstandard;
			if (formatsEntry.unreleasedHidden) entry.unreleasedHidden = formatsEntry.unreleasedHidden;
		}
	}
	const buf = 'exports.BattlePokedex = ' + es3stringify(Pokedex) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/pokedex.js', buf);
	fs.writeFileSync('play.pokemonshowdown.com/data/pokedex.json', JSON.stringify(Pokedex));
}

console.log("DONE");

/*********************************************************
 * Build moves.js
 *********************************************************/

process.stdout.write("Building `data/moves,items,abilities,typechart,learnsets.js`...");

{
	let Moves = requireNoCache('../caches/pokemon-showdown/dist/data/moves.js').Moves;
	const moveTexts = requireNoCache(dawnPath + 'dist/data/text/moves.js').MovesText;
	const SanctifiedMoves = requireNoCache(dawnPath + 'dist/data/mods/gen9sanctified/moves.js').Moves;
	const UniversalMoves = requireNoCache(dawnPath + 'dist/data/mods/gen9universal/moves.js').Moves;
	const OmnifieldMoves = requireNoCache(dawnPath + 'dist/data/mods/omnifield/moves.js').Moves;
	const RebalancedMoves = requireNoCache(dawnPath + 'dist/data/mods/gen9rebalanced/moves.js').Moves;
	const GPTMoves = requireNoCache(dawnPath + 'dist/data/mods/gen9gpt/moves.js').Moves;
	const XenoverseMoves = requireNoCache(dawnPath + 'dist/data/mods/gen5Xenoverse/moves.js').Moves;
	const BlazingMoves = requireNoCache(dawnPath + 'dist/data/mods/gen6blazing/moves.js').Moves;
	const InfinityMoves = requireNoCache(dawnPath + 'dist/data/mods/gen6infinity/moves.js').Moves;
	const DaybreakMoves = requireNoCache(dawnPath + 'dist/data/mods/gen7daybreak/moves.js').Moves;
	const UntamedMoves = requireNoCache(dawnPath + 'dist/data/mods/gen8untamed/moves.js').Moves;
	Moves = Object.assign(SanctifiedMoves, Moves);
	Moves = Object.assign(UniversalMoves, Moves);
	Moves = Object.assign(OmnifieldMoves, Moves);
	Moves = Object.assign(RebalancedMoves, Moves);
	Moves = Object.assign(GPTMoves, Moves);
	Moves = Object.assign(XenoverseMoves, Moves);
	Moves = Object.assign(BlazingMoves, Moves);
	Moves = Object.assign(InfinityMoves, Moves);
	Moves = Object.assign(DaybreakMoves, Moves);
	Moves = Object.assign(UntamedMoves, Moves);

	for (const id in Moves) {
		let move = Dex.moves.get(Moves[id].name);
		if (!move) {
			move = DawnDex.mod('gen9sanctified').moves.get(id);
			if (!move) {
				move = DawnDex.mod('gen9universal').moves.get(id);
				if (!move) {
					move = DawnDex.mod('omnifield').moves.get(id);
					if (!move) {
						move = DawnDex.mod('gen9espionage').moves.get(id);
						if (!move) {
							move = DawnDex.mod('gen9rebalanced').moves.get(id);
							if (!move) {
								move = DawnDex.mod('gen9gpt').moves.get(id);
								if (!move) {
									move = DawnDex.mod('gen5Xenoverse').moves.get(id);
									if (!move) {
										move = DawnDex.mod('gen6blazing').moves.get(id);
										if (!move) {
											move = DawnDex.mod('gen6infinity').moves.get(id);
											if (!move) {
												move = DawnDex.mod('gen7daybreak').moves.get(id);
												if (!move) {
													move = DawnDex.mod('gen8untamed').moves.get(id);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (move.desc) Moves[id].desc = move.desc;
		if (move.shortDesc) Moves[id].shortDesc = move.shortDesc;
		if (!move.desc && moveTexts[id] && typeof moveTexts[id].desc === 'string') Moves[id].desc = moveTexts[id].desc;
		if (!move.shortDesc && moveTexts[id] && typeof moveTexts[id].shortDesc === 'string') Moves[id].shortDesc = moveTexts[id].shortDesc;
	}
	const buf = 'exports.BattleMovedex = ' + es3stringify(Moves) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/moves.js', buf);
	fs.writeFileSync('play.pokemonshowdown.com/data/moves.json', JSON.stringify(Moves));
}

/*********************************************************
 * Build items.js
 *********************************************************/

{
	let Items = requireNoCache('../caches/pokemon-showdown/dist/data/items.js').Items;
	const itemTexts = requireNoCache(dawnPath + 'dist/data/text/items.js').ItemsText;
	const SanctifiedItems = requireNoCache(dawnPath + 'dist/data/mods/gen9sanctified/items.js').Items;
	const UniversalItems = requireNoCache(dawnPath + 'dist/data/mods/gen9universal/items.js').Items;
	const OmnifieldItems = requireNoCache(dawnPath + 'dist/data/mods/omnifield/items.js').Items;
	const EspionageItems = requireNoCache(dawnPath + 'dist/data/mods/gen9espionage/items.js').Items;
	const RebalancedItems = requireNoCache(dawnPath + 'dist/data/mods/gen9rebalanced/items.js').Items;
	const GPTItems = requireNoCache(dawnPath + 'dist/data/mods/gen9gpt/items.js').Items;
	const XenoverseItems = requireNoCache(dawnPath + 'dist/data/mods/gen5Xenoverse/items.js').Items;
	const BlazingItems = requireNoCache(dawnPath + 'dist/data/mods/gen6blazing/items.js').Items;
	const InfinityItems = requireNoCache(dawnPath + 'dist/data/mods/gen6infinity/items.js').Items;
	const DaybreakItems = requireNoCache(dawnPath + 'dist/data/mods/gen7daybreak/items.js').Items;
	const UntamedItems = requireNoCache(dawnPath + 'dist/data/mods/gen8untamed/items.js').Items;
	Items = Object.assign(SanctifiedItems, Items);
	Items = Object.assign(UniversalItems, Items);
	Items = Object.assign(OmnifieldItems, Items);
	Items = Object.assign(EspionageItems, Items);
	Items = Object.assign(RebalancedItems, Items);
	Items = Object.assign(GPTItems, Items);
	Items = Object.assign(XenoverseItems, Items);
	Items = Object.assign(BlazingItems, Items);
	Items = Object.assign(InfinityItems, Items);
	Items = Object.assign(DaybreakItems, Items);
	Items = Object.assign(UntamedItems, Items);
	for (const id in Items) {
		let item = DawnDex.items.get(Items[id].name);
		if (!item) {
			item = DawnDex.mod('gen9sanctified').items.get(id);
			if (!item) {
				item = DawnDex.mod('gen9universal').items.get(id);
				if (!item) {
					item = DawnDex.mod('omnifield').items.get(id);
					if (!item) {
						item = DawnDex.mod('gen9espionage').items.get(id);
						if (!item) {
							item = DawnDex.mod('gen9rebalanced').items.get(id);
							if (!item) {
								item = DawnDex.mod('gen9gpt').items.get(id);
								if (!item) {
									item = DawnDex.mod('gen5Xenoverse').items.get(id);
									if (!item) {
										item = DawnDex.mod('gen6blazing').items.get(id);
										if (!item) {
											item = DawnDex.mod('gen6infinity').items.get(id);
											if (!item) {
												item = DawnDex.mod('gen7daybreak').items.get(id);
												if (!item) {
													item = DawnDex.mod('gen8untamed').items.get(id);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (item.desc) Items[id].desc = item.desc;
		if (item.shortDesc) Items[id].shortDesc = item.shortDesc;
		if (!item.desc && itemTexts[id] && typeof itemTexts[id].desc === 'string') Items[id].desc = itemTexts[id].desc;
		if (!item.shortDesc && itemTexts[id] && typeof itemTexts[id].shortDesc === 'string') Items[id].shortDesc = itemTexts[id].shortDesc;
	}
	const buf = 'exports.BattleItems = ' + es3stringify(Items) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/items.js', buf);
}

/*********************************************************
 * Build abilities.js
 *********************************************************/

{
	let Abilities = requireNoCache('../caches/pokemon-showdown/dist/data/abilities.js').Abilities;
	const abilityTexts = requireNoCache(dawnPath + 'dist/data/text/abilities.js').AbilitiesText;
	const SanctifiedAbilities = requireNoCache(dawnPath + 'dist/data/mods/gen9sanctified/abilities.js').Abilities;
	const UniversalAbilities = requireNoCache(dawnPath + 'dist/data/mods/gen9universal/abilities.js').Abilities;
	const OmnifieldAbilities = requireNoCache(dawnPath + 'dist/data/mods/omnifield/abilities.js').Abilities;
	const RebalancedAbilities = requireNoCache(dawnPath + 'dist/data/mods/gen9rebalanced/abilities.js').Abilities;
	const GPTAbilities = requireNoCache(dawnPath + 'dist/data/mods/gen9gpt/abilities.js').Abilities;
	const XenoverseAbilities = requireNoCache(dawnPath + 'dist/data/mods/gen5Xenoverse/abilities.js').Abilities;
	const BlazingAbilities = requireNoCache(dawnPath + 'dist/data/mods/gen6blazing/abilities.js').Abilities;
	const InfinityAbilities = requireNoCache(dawnPath + 'dist/data/mods/gen6infinity/abilities.js').Abilities;
	const DaybreakAbilities = requireNoCache(dawnPath + 'dist/data/mods/gen7daybreak/abilities.js').Abilities;
	const UntamedAbilities = requireNoCache(dawnPath + 'dist/data/mods/gen8untamed/abilities.js').Abilities;
	Abilities = Object.assign(SanctifiedAbilities, Abilities);
	Abilities = Object.assign(UniversalAbilities, Abilities);
	Abilities = Object.assign(OmnifieldAbilities, Abilities);
	Abilities = Object.assign(RebalancedAbilities, Abilities);
	Abilities = Object.assign(GPTAbilities, Abilities);
	Abilities = Object.assign(XenoverseAbilities, Abilities);
	Abilities = Object.assign(BlazingAbilities, Abilities);
	Abilities = Object.assign(InfinityAbilities, Abilities);
	Abilities = Object.assign(DaybreakAbilities, Abilities);
	Abilities = Object.assign(UntamedAbilities, Abilities);

	for (const id in Abilities) {
		let ability = DawnDex.abilities.get(Abilities[id].name);
		if (!ability) {
			ability = DawnDex.mod('gen9sanctified').abilities.get(id);
			if (!ability) {
				ability = DawnDex.mod('gen9universal').abilities.get(id);
				if (!ability) {
					ability = DawnDex.mod('omnifield').abilities.get(id);
					if (!ability) {
						ability = DawnDex.mod('gen9espionage').abilities.get(id);
						if (!ability) {
							ability = DawnDex.mod('gen9rebalanced').abilities.get(id);
							if (!ability) {
								ability = DawnDex.mod('gen9gpt').abilities.get(id);
								if (!ability) {
									ability = DawnDex.mod('gen5Xenoverse').abilities.get(id);
									if (!ability) {
										ability = DawnDex.mod('gen6blazing').abilities.get(id);
										if (!ability) {
											ability = DawnDex.mod('gen6infinity').abilities.get(id);
											if (!ability) {
												ability = DawnDex.mod('gen7daybreak').abilities.get(id);
												if (!ability) {
													ability = DawnDex.mod('gen8untamed').abilities.get(id);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (ability.desc) Abilities[id].desc = ability.desc;
		if (ability.shortDesc) Abilities[id].shortDesc = ability.shortDesc;
		if (!ability.desc && abilityTexts[id] && typeof abilityTexts[id].desc === 'string') Abilities[id].desc = abilityTexts[id].desc;
		if (!ability.shortDesc && abilityTexts[id] && typeof abilityTexts[id].shortDesc === 'string') Abilities[id].shortDesc = abilityTexts[id].shortDesc;
	}
	const buf = 'exports.BattleAbilities = ' + es3stringify(Abilities) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/abilities.js', buf);
}

/*********************************************************
 * Build typechart.js
 *********************************************************/

{
	let TypeChart = requireNoCache('../caches/pokemon-showdown/dist/data/typechart.js').TypeChart;
	const SanctifiedTypeChart = requireNoCache(dawnPath + 'dist/data/mods/gen9sanctified/typechart.js').TypeChart;
	const UniversalTypeChart = requireNoCache(dawnPath + 'dist/data/mods/gen9universal/typechart.js').TypeChart;
	const XenoverseTypeChart = requireNoCache(dawnPath + 'dist/data/mods/gen5Xenoverse/typechart.js').TypeChart;
	const BlazingTypeChart = requireNoCache(dawnPath + 'dist/data/mods/gen6blazing/typechart.js').TypeChart;
	const InfinityTypeChart = requireNoCache(dawnPath + 'dist/data/mods/gen6infinity/typechart.js').TypeChart;
	const UntamedTypeChart = requireNoCache(dawnPath + 'dist/data/mods/gen8untamed/typechart.js').TypeChart;
	TypeChart = Object.assign(SanctifiedTypeChart, TypeChart);
	TypeChart = Object.assign(UniversalTypeChart, TypeChart);
	TypeChart = Object.assign(XenoverseTypeChart, TypeChart);
	TypeChart = Object.assign(BlazingTypeChart, TypeChart);
	TypeChart = Object.assign(InfinityTypeChart, TypeChart);
	TypeChart = Object.assign(UntamedTypeChart, TypeChart);
	const buf = 'exports.BattleTypeChart = ' + es3stringify(TypeChart) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/typechart.js', buf);
}

/*********************************************************
 * Build aliases.js
 *********************************************************/

{
	const Aliases = requireNoCache('../caches/pokemon-showdown/dist/data/aliases.js').Aliases;
	const buf = 'exports.BattleAliases = ' + es3stringify(Aliases) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/aliases.js', buf);
}

/*********************************************************
 * Build formats-data.js
 *********************************************************/

{
	let FormatsData = requireNoCache('../caches/pokemon-showdown/dist/data/formats-data.js').FormatsData;
	const SanctifiedFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9sanctified/formats-data.js').FormatsData;
	const UniversalFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9universal/formats-data.js').FormatsData;
	const OmnifieldFormatsData = requireNoCache(dawnPath + 'dist/data/mods/omnifield/formats-data.js').FormatsData;
	const EspionageFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9espionage/formats-data.js').FormatsData;
	const RebalancedFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9rebalanced/formats-data.js').FormatsData;
	const GPTFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen9gpt/formats-data.js').FormatsData;
	const ThirtyFivePokesFormatsData = requireNoCache(dawnPath + 'dist/data/mods/35_pokes/formats-data.js').FormatsData;
	const XenoverseFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen5Xenoverse/formats-data.js').FormatsData;
	const BlazingFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen6blazing/formats-data.js').FormatsData;
	const InfinityFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen6infinity/formats-data.js').FormatsData;
	const DaybreakFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen7daybreak/formats-data.js').FormatsData;
	const UntamedFormatsData = requireNoCache(dawnPath + 'dist/data/mods/gen8untamed/formats-data.js').FormatsData;
	FormatsData = Object.assign(SanctifiedFormatsData, FormatsData);
	FormatsData = Object.assign(UniversalFormatsData, FormatsData);
	FormatsData = Object.assign(OmnifieldFormatsData, FormatsData);
	FormatsData = Object.assign(EspionageFormatsData, FormatsData);
	FormatsData = Object.assign(RebalancedFormatsData, FormatsData);
	FormatsData = Object.assign(GPTFormatsData, FormatsData);
	FormatsData = Object.assign(ThirtyFivePokesFormatsData, FormatsData);
	FormatsData = Object.assign(XenoverseFormatsData, FormatsData);
	FormatsData = Object.assign(BlazingFormatsData, FormatsData);
	FormatsData = Object.assign(InfinityFormatsData, FormatsData);
	FormatsData = Object.assign(DaybreakFormatsData, FormatsData);
	FormatsData = Object.assign(UntamedFormatsData, FormatsData);
	const buf = 'exports.BattleFormatsData = ' + es3stringify(FormatsData) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/formats-data.js', buf);
}

/*********************************************************
 * Build formats.js
 *********************************************************/

{
	const Formats = requireNoCache(dawnPath + 'dist/config/formats.js').Formats;
	const buf = 'exports.Formats = ' + es3stringify(Formats) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/formats.js', buf);
}

/*********************************************************
 * Build learnsets.js
 *********************************************************/

{
	let Learnsets = requireNoCache('../caches/pokemon-showdown/dist/data/learnsets.js').Learnsets;
	const SanctifiedLearnsets = requireNoCache(dawnPath + 'dist/data/mods/gen9sanctified/learnsets.js').Learnsets;
	const UniversalLearnsets = requireNoCache(dawnPath + 'dist/data/mods/gen9universal/learnsets.js').Learnsets;
	const OmnifieldLearnsets = requireNoCache(dawnPath + 'dist/data/mods/omnifield/learnsets.js').Learnsets;
	const EspionageLearnsets = requireNoCache(dawnPath + 'dist/data/mods/gen9espionage/learnsets.js').Learnsets;
	const RebalancedLearnsets = requireNoCache(dawnPath + 'dist/data/mods/gen9rebalanced/learnsets.js').Learnsets;
	const GPTLearnsets = requireNoCache(dawnPath + 'dist/data/mods/gen9gpt/learnsets.js').Learnsets;
	const BlazingLearnsets = requireNoCache(dawnPath + 'dist/data/mods/gen6blazing/learnsets.js').Learnsets;
	const InfinityLearnsets = requireNoCache(dawnPath + 'dist/data/mods/gen6infinity/learnsets.js').Learnsets;
	const UntamedLearnsets = requireNoCache(dawnPath + 'dist/data/mods/gen8untamed/learnsets.js').Learnsets;
	Learnsets = Object.assign(SanctifiedLearnsets, Learnsets);
	Learnsets = Object.assign(UniversalLearnsets, Learnsets);
	Learnsets = Object.assign(OmnifieldLearnsets, Learnsets);
	Learnsets = Object.assign(EspionageLearnsets, Learnsets);
	Learnsets = Object.assign(RebalancedLearnsets, Learnsets);
	Learnsets = Object.assign(GPTLearnsets, Learnsets);
	Learnsets = Object.assign(BlazingLearnsets, Learnsets);
	Learnsets = Object.assign(InfinityLearnsets, Learnsets);
	Learnsets = Object.assign(UntamedLearnsets, Learnsets);
	const buf = 'exports.BattleLearnsets = ' + es3stringify(Learnsets) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/learnsets.js', buf);
	fs.writeFileSync('play.pokemonshowdown.com/data/learnsets.json', JSON.stringify(Learnsets));
}

/*********************************************************
 * Build text.js
 *********************************************************/

{
	const textData = DawnDex.loadTextData();
	const Text = textData.Default;

	function assignData(id, entry) {
		for (const key in entry) {
			if (['name', 'desc', 'shortDesc'].includes(key)) continue;
			const textEntry = Text[id] || (Text[id] = {});
			if (key.startsWith('gen')) {
				for (const modKey in entry[key]) {
					if (['desc', 'shortDesc'].includes(key)) continue;
					textEntry[modKey + 'Gen' + key.charAt(3)] = entry[key][modKey];
				}
			} else {
				textEntry[key] = entry[key];
			}
		}
	}

	for (const id in textData.Moves) assignData(id, textData.Moves[id]);
	for (const id in textData.Abilities) assignData(id, textData.Abilities[id]);
	for (const id in textData.Items) assignData(id, textData.Items[id]);

	const buf = 'exports.BattleText = ' + es3stringify(Text) + ';';
	fs.writeFileSync('play.pokemonshowdown.com/data/text.js', buf);
}

console.log("DONE");